# -*- coding: utf-8 -*-
"""Mountain Paths

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zt6kYuCyr8NYFrOmatTt85Jgzy4hoIX0
"""

from queue import PriorityQueue
import numpy

class State(object):
    def __init__(self, value, location, parent, start=0, end=0):
        self.children = []
        self.parent = parent
        self.location = location
        self.value = value
        self.dist = 0
        if parent:  
            self.path = parent.path[:]
            self.path.append(location)
            self.start = parent.start
            self.end = parent.end
        else:
            self.path = [location]
            self.start = start
            self.end = end
    def getDist(self):
        pass
    def createChildren(self):
        pass

class Sub_State(State):
    def __init__(self, value, location, parent, start=0, end=0):
        super(Sub_State, self).__init__(value, location, parent, start, end)
        self.dist = self.getDist()
    def getDist(self):
        if self.parent:
            return self.end - self.location[1] + abs(self.value - self.parent.value)
        return 100000
    def createChildren(self):
        if self.location[0] > 0:
            self.children.append(Sub_State(getValue(self.location[0] - 1, self.location[1]), (self.location[0] - 1, self.location[1]), self, self.start, self.end))
            try: self.children.append(Sub_State(getValue(self.location[0] - 1, self.location[1] + 1), (self.location[0] - 1, self.location[1] + 1), self, self.start, self.end))
            except: pass
        if self.location[1] > 0:
            self.children.append(Sub_State(getValue(self.location[0], self.location[1] - 1), (self.location[0], self.location[1] - 1), self, self.start, self.end))
            try: self.children.append(Sub_State(getValue(self.location[0] + 1, self.location[1] - 1), (self.location[0] + 1, self.location[1] - 1), self, self.start, self.end))
            except: pass
        if self.location[0] > 0 and self.location[1] > 0:
            self.children.append(Sub_State(getValue(self.location[0] - 1, self.location[1] - 1), (self.location[0] - 1, self.location[1] - 1), self, self.start, self.end))
        try:
            self.children.append(Sub_State(getValue(self.location[0] + 1, self.location[1]), (self.location[0] + 1, self.location[1]), self, self.start, self.end))
            self.children.append(Sub_State(getValue(self.location[0], self.location[1] + 1), (self.location[0], self.location[1] + 1), self, self.start, self.end))
            self.children.append(Sub_State(getValue(self.location[0] + 1, self.location[1] + 1), (self.location[0] + 1, self.location[1] + 1), self, self.start, self.end))
        except: pass
    def __lt__(self, other):
        return self.getDist() < other.getDist()

class AStar:
    def __init__(self, start, end):
        self.path = []
        self.visited = []
        self.priorityQueue = PriorityQueue()
        self.start = start
        self.end = end
    def solve(self):
        startState = Sub_State(getValue(self.start[0], self.start[1]), (self.start[0], self.start[1]), 0, self.start, self.end)
        self.priorityQueue.put(startState)
        while not self.path and self.priorityQueue.qsize():
            closestChild = self.priorityQueue.get()
            closestChild.createChildren()
            for child in closestChild.children:
                if child.location not in self.visited:
                    self.visited.append(child.location)
                    if not child.dist:
                        self.path = child.path
                        break
                    self.priorityQueue.put(child)
        if not self.path: print('No possible value')
        return self.path
    def getValue(r, c): 
      return MAP[r][c]